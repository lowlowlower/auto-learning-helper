# 🔍 插件工作原理：为什么跳转后还能继续监测？

## 💡 核心原理

浏览器扩展（Chrome Extension）有一个强大的功能：**Content Script（内容脚本）会在每个匹配的页面自动注入！**

---

## 📋 详细工作流程

### 1️⃣ 插件配置（manifest.json）

```json
"content_scripts": [
  {
    "matches": ["<all_urls>"],     // 匹配所有网址
    "js": ["content.js"],           // 要注入的脚本
    "run_at": "document_end"        // 在页面加载完成后运行
  }
]
```

**含义：**
- ✅ `"matches": ["<all_urls>"]` - 插件会在**所有网页**上运行
- ✅ `"js": ["content.js"]` - 每个页面都会自动加载 `content.js`
- ✅ `"run_at": "document_end"` - 页面DOM加载完成后立即运行

### 2️⃣ 自动注入机制

```
用户打开页面A（课程列表）
    ↓
浏览器自动注入 content.js
    ↓
content.js 执行初始化代码
    ↓
点击课程 → 跳转到页面B（视频页）
    ↓
浏览器再次自动注入 content.js  ← 关键！
    ↓
content.js 执行初始化代码
    ↓
检查运行状态 → 继续监测
```

**每次页面跳转，content.js都会重新加载！**

---

## 🔑 关键代码：自动恢复机制

### content.js 的初始化代码（第9-17行）：

```javascript
// 初始化
(async function init() {
  const result = await chrome.storage.local.get(['isRunning']);
  isRunning = result.isRunning || false;
  
  if (isRunning) {
    log('检测到上次运行状态，正在恢复...');
    start();  // 自动恢复运行状态
  }
})();
```

**工作原理：**

1. **新页面加载** → content.js 自动运行
2. **检查存储** → 从 `chrome.storage.local` 读取 `isRunning` 状态
3. **如果是 true** → 说明用户之前点击了"开始学习"
4. **自动恢复** → 调用 `start()` 函数，继续监测

---

## 💾 Chrome Storage API：跨页面数据共享

### 为什么能记住运行状态？

```javascript
// 点击"开始学习"时保存状态
await chrome.storage.local.set({ isRunning: true });

// 新页面加载时读取状态
const result = await chrome.storage.local.get(['isRunning']);
```

**Chrome Storage 特点：**
- ✅ **跨页面共享** - 所有标签页都能访问同一份数据
- ✅ **持久化存储** - 关闭浏览器也不会丢失
- ✅ **实时同步** - 一个页面修改，其他页面立即可见

**存储的数据：**
```javascript
{
  isRunning: true/false,           // 是否运行中
  learnedCount: 5,                // 已学习课程数
  currentCourse: "主讲人：韩庆祥",  // 当前课程
  learnedCourses: [...],          // 已学习课程列表
  videoSpeed: "1.5",              // 视频倍速
  autoNext: true,                 // 自动下一课
  loopLearning: true              // 循环学习
}
```

---

## 🔄 完整流程示例

### 场景：从课程列表跳转到视频页

#### **步骤1：课程列表页**

```
【页面A：课程列表】
    ↓
浏览器加载 content.js
    ↓
执行 init() 函数
    ↓
读取 storage: { isRunning: true }  ← 之前点击了"开始学习"
    ↓
调用 start() 函数
    ↓
检测页面类型 → 发现是课程列表
    ↓
找到第一个未学习的课程
    ↓
点击课程卡片 → 跳转！
```

#### **步骤2：页面跳转**

```
【页面跳转中...】

旧页面（列表页）：
  - content.js 被卸载
  - 所有变量、定时器都清空

新页面（视频页）：
  - 开始加载HTML
  - DOM构建完成
  - 浏览器自动注入 content.js ← 重新加载！
```

#### **步骤3：视频页面**

```
【页面B：视频页】
    ↓
浏览器加载 content.js（新实例）
    ↓
执行 init() 函数
    ↓
读取 storage: { isRunning: true }  ← 数据还在！
    ↓
调用 start() 函数
    ↓
检测页面类型 → 发现是视频页
    ↓
点击播放按钮 → 开始播放
    ↓
监控视频完成
    ↓
完成后返回列表页 → 又一次跳转！
```

**循环往复！**

---

## 🧪 实验：验证自动注入

### 在任意页面的Console运行：

```javascript
// 1. 查看 content.js 是否已加载
console.log('Content script 已加载:', typeof chrome !== 'undefined' && chrome.runtime);

// 2. 查看当前运行状态
chrome.storage.local.get(['isRunning'], (result) => {
  console.log('当前运行状态:', result.isRunning);
});

// 3. 手动触发跳转，观察日志
setTimeout(() => {
  window.location.href = 'https://web.scgb.gov.cn/#/myClass?...';
  // 跳转后，新页面的Console会显示：
  // "自动学习助手内容脚本已加载"
  // "检测到上次运行状态，正在恢复..."
}, 3000);
```

---

## 📊 对比：传统网页 vs 浏览器扩展

### 传统网页脚本：

```
页面A加载 → 运行脚本A
    ↓
点击跳转 → 页面B加载
    ↓
❌ 脚本A被清空，无法继续运行
```

### 浏览器扩展 Content Script：

```
页面A加载 → 自动注入 content.js
    ↓
点击跳转 → 页面B加载
    ↓
✅ 自动注入 content.js（新实例）
    ↓
✅ 从 Storage 恢复状态
    ↓
✅ 继续运行
```

---

## 🎯 为什么这样设计？

### 优点：

1. **跨页面工作** ✅
   - 不需要用户重复操作
   - 自动跟踪页面跳转

2. **状态持久化** ✅
   - 关闭浏览器也不丢失
   - 下次打开继续运行

3. **自动恢复** ✅
   - 页面刷新后自动恢复
   - 跳转后自动继续

4. **独立运行** ✅
   - 不影响网页原有功能
   - 可以在任何网站上工作

### 限制：

1. **需要重新初始化** ⚠️
   - 每次跳转都是新的 content.js 实例
   - 内存中的变量会丢失

2. **依赖 Storage** ⚠️
   - 必须将状态保存到 Storage
   - 才能跨页面共享

3. **检测延迟** ⚠️
   - 新页面加载需要时间
   - 有2-3秒的检测延迟（`setInterval 3秒`）

---

## 🔧 关键配置说明

### manifest.json 中的关键设置：

```json
{
  // 1. Content Scripts 配置
  "content_scripts": [
    {
      "matches": ["<all_urls>"],  // ← 所有页面都注入
      "js": ["content.js"],
      "run_at": "document_end"    // ← 页面加载完立即运行
    }
  ],
  
  // 2. 权限配置
  "permissions": [
    "storage",                    // ← 允许使用 Storage API
    "tabs",                       // ← 允许访问标签页信息
    "activeTab"                   // ← 允许访问当前激活的标签页
  ],
  
  // 3. 主机权限
  "host_permissions": [
    "<all_urls>"                  // ← 允许在所有网站运行
  ]
}
```

---

## 💡 Console 日志验证

### 页面跳转时的日志：

```javascript
// 【课程列表页】
自动学习助手内容脚本已加载
[自动学习助手] 检测到上次运行状态，正在恢复...
[自动学习助手] 🚀 开始自动学习
[自动学习助手] ✅ 这是课程列表页面
[自动学习助手] 🖱️ 点击课程卡片

// ========== 页面跳转 ==========

// 【视频播放页】（新页面）
自动学习助手内容脚本已加载          ← 重新加载了！
[自动学习助手] 检测到上次运行状态，正在恢复...  ← 自动恢复！
[自动学习助手] 🚀 开始自动学习
[自动学习助手] ✅ 这是视频播放页面
[自动学习助手] ✅ 已点击播放按钮
```

**关键日志：**
- `"自动学习助手内容脚本已加载"` - 每次页面加载都会显示
- `"检测到上次运行状态，正在恢复..."` - 说明自动恢复成功

---

## 🎉 总结

### 为什么跳转后还能监测？

1. ✅ **content.js 在所有页面自动注入**（manifest.json配置）
2. ✅ **每次跳转都重新加载 content.js**（浏览器机制）
3. ✅ **运行状态保存在 Storage**（跨页面共享）
4. ✅ **新页面自动恢复运行状态**（init函数检查）

### 简单理解：

```
就像给每个网页都派了一个"助手"
每个网页的助手都能：
1. 读取共同的"任务清单"（Storage）
2. 看到之前的助手记录的状态
3. 继续完成未完成的任务
4. 更新任务进度给下一个助手
```

---

## 🧪 测试验证

在Console运行以下代码，验证跨页面工作：

```javascript
// 1. 保存测试状态
chrome.storage.local.set({ 
  testValue: '这是测试数据',
  timestamp: Date.now()
});

console.log('✅ 已保存数据到 Storage');

// 2. 3秒后跳转到其他页面
setTimeout(() => {
  console.log('准备跳转...');
  // 替换为您的学习平台URL
  window.location.href = 'https://web.scgb.gov.cn/';
}, 3000);

// 3. 在新页面的Console运行：
chrome.storage.local.get(['testValue', 'timestamp'], (result) => {
  console.log('从 Storage 读取数据:', result);
  console.log('数据还在！跨页面成功！');
});
```

---

**现在明白了吗？浏览器扩展的 Content Script 会在每个页面自动注入，并通过 Storage 共享状态，实现跨页面的持续监测！🎉**

